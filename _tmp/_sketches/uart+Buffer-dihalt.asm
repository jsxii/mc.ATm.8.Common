;===============================================================================
; Read from loop Buffer
; IN: NONE
; OUT: 	R17 - Data,
;		R19 - ERROR CODE
 
Buff_Pop:
CLI 				; Запрещаем прерыания. 
				; Но лучше запретить прерывания конкретно  от 
				; UART, чем запрещать вообще все.
LDI		XL,low(IN_buff)		; Берем адрес начала буффера
LDI		XH,high(IN_buff)
LDS		R16,IN_PTR_E		; Берем смещение точки записи
LDS		R18,IN_PTR_S		; Берем смещение точки чтения			
LDS		R19,IN_FULL		; Берм флаг переполнения

CPI		R19,1			; Если буффер переполнен, то указатель начала
BREQ	NeedPop			; Равен указателю конца. Это надо учесть.

CP		R18,R16			; Указатель чтения достиг указателя записи?
BRNE	NeedPop			; Нет! Буффер не пуст. Работаем дальше

LDI		R19,1			; Код ошибки - пустой буффер!

RJMP	_TX_OUT			; Выходим

NeedPop:
CLR		R17			; Получаем ноль
STS		IN_FULL,R17		; Сбрасываем флаг переполнения

ADD		XL,R18			; Сложением адреса со смещением
ADC		XH,R17			; получаем адрес точки чтения

LD		R17,X			; Берем байт из буффера
CLR		R19			; Сброс кода ошибки

INC		R18			; Увеличиваем смещение указателя чтения

CPI		R18,MAXBUFF_OUT		; Достигли конца кольца?
BRNE	_TX_OUT			; Нет? 

CLR		R18			; Да? Сбрасываем, переставляя на 0

_TX_OUT:
STS		IN_PTR_S,R18		; Сохраняем указатель
SEI				; Разрешаем прерывания
RET
;===============================================================================
; Load Loop Buffer 
; IN R19 	- DATA
; OUT R19 	- ERROR CODE 
Buff_Push:
CLI 					; Запрет прерываний. 
LDI		XL,low(OUT_buff)	; Берем адрес начала буффера
LDI		XH,high(OUT_buff)
LDS		R16,OUT_PTR_E		; Берем смещение точки записи
LDS		R18,OUT_PTR_S		; Берем смещение точки чтения

ADD		XL,R16			; Сложением адреса со смещением
CLR		R17			; получаем адрес точки записи
ADC		XH,R17

ST		X,R19			; сохраняем их в кольцо
CLR		R19			; Очищаем R19, теперь там код ошибки
					; Который вернет подпрограмма

INC		R16			; Увеличиваем смещение

CPI		R16,MAXBUFF_OUT		; Если достигли конца 
BRNE	_NoEnd
CLR		R16			; переставляем на начало

_NoEnd:
CP		R16,R18			; Дошли до непрочитанных данных?
BRNE	_RX_OUT				; Если нет, то просто выходим
 
_RX_FULL:
LDI		R19,1			; Если да, то буффер переполнен.
STS		OUT_FULL,R19		; Записываем флаг наполненности
					; В R19 остается 1 - код ошибки переполнения
 
_RX_OUT:
STS		OUT_PTR_E,R16		; Сохраняем смещение. Выходим
SEI 					; Разрешение прерываний
RET
;== UDRE Int ===================================================================
UD_OK:
;PUSHF
PUSH	R16
IN		R16,SREG
PUSH	R16
;
PUSH	R17
PUSH	R18
PUSH	R19
PUSH	XL
PUSH	XH

LDI		XL,low(OUT_buff)	; Берем адрес начала буффера
LDI		XH,high(OUT_buff)
LDS		R16,OUT_PTR_E		; Берем смещение точки записи
LDS		R18,OUT_PTR_S		; Берем смещение точки чтения			
LDS		R19,OUT_FULL		; Берм флаг переполнения

CPI		R19,1			; Если буффер переполнен, то указатель начала
BREQ	NeedSend		; Равер указателю конца. Это надо учесть.

CP		R18,R16			; Указатель чтения достиг указателя записи?
BRNE	NeedSend		; Нет! Буффер не пуст. Надо слать дальше

LDI 		R16,1<<RXEN|1<<TXEN|1<<RXCIE|1<<TXCIE|0<<UDRIE	; Запрет прерывания
OUT 		UCSRB, R16					; По пустому UDR
RJMP	TX_OUT			; Выходим

NeedSend:
CLR		R17			; Получаем ноль
STS		OUT_FULL,R17		; Сбрасываем флаг переполнения

ADD		XL,R18			; Сложением адреса со смещением
ADC		XH,R17			; получаем адрес точки чтения

LD		R17,X			; Берем байт из буффера
OUT		UDR,R17			; Отправляем его в USART

INC		R18			; Увеличиваем смещение указателя чтения

CPI		R18,MAXBUFF_OUT		; Достигли конца кольца?
BRNE	TX_OUT			; Нет? 

CLR		R18			; Да? Сбрасываем, переставляя на 0

TX_OUT:
STS		OUT_PTR_S,R18		; Сохраняем указатель

POP		XH
POP		XL
POP		R19
POP		R18
POP		R17
;POPF				; Выходим, достав все из стека
POP		R16
OUT		SREG,R16
POP		R16
;
RETI
;== RxC Int ====================================================================
RX_OK:
;PUSHF				; Макрос, пихающий в стек SREG и R16
PUSH	R16
IN		R16,SREG
PUSH	R16
;
PUSH	R17
PUSH	R18
PUSH	XL
PUSH	XH
 
LDI		XL,low(IN_buff)		; Берем адрес начала буффера
LDI		XH,high(IN_buff)
LDS		R16,IN_PTR_E		; Берем смещение точки записи
LDS		R18,IN_PTR_S		; Берем смещение точки чтения
 
ADD		XL,R16			; Сложением адреса со смещением
CLR		R17			; получаем адрес точки записи
ADC		XH,R17

IN		R17,UDR			; Забираем данные
ST		X,R17			; сохраняем их в кольцо

INC		R16			; Увеличиваем смещение

CPI		R16,MAXBUFF_IN		; Если достигли конца 
BRNE	NoEnd
CLR		R16			; переставляем на начало

NoEnd:
CP		R16,R18			; Дошли до непрочитанных данных?
BRNE	RX_OUT			; Если нет, то просто выходим

RX_FULL:
LDI		R18,1			; Если да, то буффер переполнен.
STS		IN_FULL,R18		; Записываем флаг наполненности

RX_OUT:
STS		IN_PTR_E,R16		; Сохраняем смещение. Выходим

POP		XH
POP		XL
POP		R18
POP		R17
;POPF				; Достаем SREG и R16
POP		R16
OUT		SREG,R16
POP		R16
;
RETI
;===============================================================================
.equ MAXBUFF_IN = 10	; Размер в байтах
.equ MAXBUFF_OUT = 10
.DSEG
IN_buff:	.byte	MAXBUFF_IN	; Буфер приема
IN_PTR_S:	.byte	1		; Указатель начала
IN_PTR_E:	.byte	1		; Указатель конца
IN_FULL:	.byte	1		; Флаг переполнения
OUT_buff:	.byte	MAXBUFF_OUT	; Буфер передачи
OUT_PTR_S:	.byte	1		; Указатель начала
OUT_PTR_E:	.byte	1		; Указатель конца
OUT_FULL:	.byte	1		; Флаг переполнения.
